<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¶„ë¦¬ë°°ì¶œ ì„œë¹„ìŠ¤ êµ¬ì¡°ë„</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f4f6f8;
            font-family: 'Noto Sans KR', sans-serif;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            z-index: 100;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .legend-item:last-child { margin-bottom: 0; }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 4px;
            margin-right: 8px;
        }

        button {
            padding: 5px 10px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Noto Sans KR', sans-serif;
            transition: all 0.2s;
            display: flex;              /* ì•„ì´ì½˜ ì •ë ¬ì„ ìœ„í•´ ì¶”ê°€ */
            align-items: center;        /* ì•„ì´ì½˜ ì •ë ¬ì„ ìœ„í•´ ì¶”ê°€ */
            gap: 5px;                   /* ì•„ì´ì½˜ê³¼ í…ìŠ¤íŠ¸ ê°„ê²© */
        }

        button:hover {
            background: #f0f0f0;
        }

        .helper-text {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            color: #555;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="diagramCanvas"></canvas>
        
        <div class="helper-text">
            ğŸ–±ï¸ ë“œë˜ê·¸í•˜ì—¬ ì´ë™ â€¢ íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ
        </div>

        <div class="legend">
            <div style="font-weight:bold; margin-bottom:8px;">ë²”ë¡€</div>
            <div class="legend-item"><div class="dot" style="background:#FF9F43;"></div>ë©”ì¸ ì„œë¹„ìŠ¤</div>
            <div class="legend-item"><div class="dot" style="background:#FFEAA7; border: 1px solid #FDCB6E;"></div>ì¹´í…Œê³ ë¦¬/ê¸°ë°˜</div>
            <div class="legend-item"><div class="dot" style="background:#E3F2FD; border: 1px solid #90CAF9;"></div>ê¸°ëŠ¥ (ì…ë ¥/í™œì„±)</div>
            <div class="legend-item"><div class="dot" style="background:#F5F5F5; border: 1px solid #E0E0E0;"></div>ê¸°ëŠ¥ (ì¶œë ¥/ì •ë³´)</div>
        </div>

        <div class="controls">
            <button onclick="resetView()">ğŸ”„ í™”ë©´ ì´ˆê¸°í™”</button>
            <button onclick="downloadImage()">ğŸ’¾ íˆ¬ëª… ë°°ê²½ ì €ì¥</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('diagramCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        // ìƒíƒœ ë³€ìˆ˜
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let startX, startY;
        let hoveredNode = null;

        // ìƒìˆ˜ ì„¤ì •
        const NODE_WIDTH = 210; // ë„ˆë¹„ í™•ëŒ€ (180 -> 210)
        const NODE_HEIGHT = 60;  // ë†’ì´ í™•ëŒ€ (50 -> 60)
        const VERTICAL_GAP = 70;
        const HORIZONTAL_GAP = 40;
        const RADIUS = 8;

        // ìƒ‰ìƒ íŒ”ë ˆíŠ¸
        const COLORS = {
            root: { fill: '#FF9F43', stroke: '#E67E22', text: '#fff' },
            aux: { fill: '#FFEAA7', stroke: '#FDCB6E', text: '#333' }, // ìƒë‹¨ ë³´ì¡°
            category: { fill: '#FFEAA7', stroke: '#FDCB6E', text: '#333' }, // ë…¸ë€ìƒ‰ ì¹´í…Œê³ ë¦¬
            blue: { fill: '#E3F2FD', stroke: '#90CAF9', text: '#1565C0' }, // íŒŒë€ìƒ‰ (ì…ë ¥)
            gray: { fill: '#FAFAFA', stroke: '#E0E0E0', text: '#616161' }, // íšŒìƒ‰ (ì¶œë ¥)
            line: '#B0BEC5'
        };

        // ë°ì´í„° ì •ì˜ (íŠ¸ë¦¬ êµ¬ì¡°)
        // type: root, aux, category, blue, gray
        const data = {
            root: { id: 'root', text: 'ë¶„ë¦¬ë°°ì¶œ ì„œë¹„ìŠ¤', type: 'root' },
            aux: [
                { id: 'aux1', text: 'ë¡œê·¸ì¸ ë°\níšŒì›ê´€ë¦¬', type: 'aux' },
                { id: 'aux2', text: 'ê°œì¸ì •ë³´/ë™ì˜', type: 'aux' },
                { id: 'aux3', text: 'UXÂ·ì ‘ê·¼ì„±\nÂ·ì§€ì—­í™”', type: 'aux' }
            ],
            columns: [
                {
                    head: { id: 'c1', text: 'AI ê¸°ë°˜\níê¸°ë¬¼ ì¸ì‹', type: 'category' },
                    children: [
                        { text: 'ì´¬ì˜ ê¸°ëŠ¥', type: 'blue' },
                        { text: 'íê¸°ë¬¼ í’ˆëª© ì¸ì‹', type: 'blue' },
                        { text: 'OCR ì¬ì§ˆ ì¸ì‹', type: 'blue' },
                        { text: 'ë°”ì½”ë“œ ì¸ì‹', type: 'blue' },
                        { text: 'ë³µí•©ì¬ì§ˆ ë§¤í•‘', type: 'blue' },
                        { text: 'ì‚¬ìš©ì í”¼ë“œë°± ìˆ˜ì§‘', type: 'blue' },
                        { text: 'ì¸ì‹ ì‹ ë¢°ë„ ì•ˆë‚´', type: 'gray' },
                        { text: 'ì˜¨ë””ë°”ì´ìŠ¤/\ní´ë¼ìš°ë“œ í•˜ì´ë¸Œë¦¬ë“œ', type: 'gray' } // ì¤„ë°”ê¿ˆ ì¡°ì •
                    ]
                },
                {
                    head: { id: 'c2', text: 'ë°°ì¶œ ê°€ì´ë“œ ë°\nê·œì • ë§¤í•‘', type: 'category' },
                    children: [
                        { text: 'GPS ìœ„ì¹˜', type: 'blue' },
                        { text: 'ë°°ì¶œ ê·œì • ì¡°íšŒ', type: 'gray' },
                        { text: 'ë§ì¶¤ ê°€ì´ë“œ ìƒì„±', type: 'gray' },
                        { text: 'ê°€ì´ë“œ ì €ì¥', type: 'gray' }
                    ]
                },
                {
                    head: { id: 'c3', text: 'ì¸ì¦ ë°\ní¬ì¸íŠ¸Â·ì»¤ë®¤ë‹ˆí‹°', type: 'category' },
                    children: [
                        { text: 'ì¸ì¦ìƒ· ì—…ë¡œë“œ', type: 'blue' },
                        { text: 'í¬ì¸íŠ¸ ì ë¦½', type: 'blue' },
                        { text: 'í¬ì¸íŠ¸ ì‚¬ìš©', type: 'blue' },
                        { text: 'ê²Œì‹œê¸€ ì‘ì„±', type: 'blue' },
                        { text: 'ëŒ“ê¸€/ì¢‹ì•„ìš”', type: 'blue' },
                        { text: 'ë­í‚¹ ì‹œìŠ¤í…œ', type: 'gray' },
                        { text: 'ì±Œë¦°ì§€ ì‹œìŠ¤í…œ', type: 'gray' },
                        { text: 'ì»¤ë®¤ë‹ˆí‹° ì¸ì¦ ê²€ì¦', type: 'gray' },
                        { text: 'ë¶€ì •í–‰ìœ„ íƒì§€', type: 'gray' }
                    ]
                },
                {
                    head: { id: 'c4', text: 'ëŒ€ë¦¬ìˆ˜ê±° ë§¤ì¹­', type: 'category' },
                    children: [
                        { text: 'ìˆ˜ê±° ìš”ì²­ ìƒì„±', type: 'blue' },
                        { text: 'ìˆ˜ê±° ë¹„ìš© ì§€ë¶ˆ', type: 'blue' },
                        { text: 'ìˆ˜ê±° ì™„ë£Œ ì¸ì¦', type: 'blue' },
                        { text: 'ë§¤ì¹­ ê¸°ëŠ¥', type: 'gray' },
                        { text: 'ë³´ìƒ ì§€ê¸‰', type: 'gray' },
                        { text: 'ìˆ˜ê±°ì ì¸ì¦\nÂ·í‰íŒ ì‹œìŠ¤í…œ', type: 'gray' } // ì¤„ë°”ê¿ˆ ì¶”ê°€
                    ]
                }
            ]
        };

        let nodes = []; // ë Œë”ë§ì„ ìœ„í•´ ê³„ì‚°ëœ ë…¸ë“œ ë¦¬ìŠ¤íŠ¸

        function initLayout() {
            nodes = [];
            
            // ì „ì²´ ìº”ë²„ìŠ¤ ì¤‘ì•™ ê³„ì‚°ì„ ìœ„í•œ ë„ˆë¹„ ì¶”ì •
            const colWidth = NODE_WIDTH + HORIZONTAL_GAP;
            const totalWidth = colWidth * data.columns.length;
            const startX_pos = -totalWidth / 2 + NODE_WIDTH / 2;

            // 1. Root Node
            nodes.push({
                ...data.root,
                x: 0,
                y: -300,
                w: NODE_WIDTH,
                h: NODE_HEIGHT
            });

            // 2. Aux Nodes (Root ì£¼ë³€)
            // ì™¼ìª½
            nodes.push({
                ...data.aux[0],
                x: -NODE_WIDTH * 1.5,
                y: -300,
                w: NODE_WIDTH,
                h: NODE_HEIGHT
            });
            // ì˜¤ë¥¸ìª½ 1
            nodes.push({
                ...data.aux[1],
                x: NODE_WIDTH * 1.5,
                y: -300,
                w: NODE_WIDTH,
                h: NODE_HEIGHT
            });
            // ì˜¤ë¥¸ìª½ 2
            nodes.push({
                ...data.aux[2],
                x: NODE_WIDTH * 2.8,
                y: -300,
                w: NODE_WIDTH,
                h: NODE_HEIGHT
            });

            // 3. Columns
            data.columns.forEach((col, idx) => {
                const colX = startX_pos + (idx * colWidth);
                const startY_pos = -150;

                // Category Head
                const headNode = {
                    ...col.head,
                    x: colX,
                    y: startY_pos,
                    w: NODE_WIDTH,
                    h: NODE_HEIGHT * 1.2, // ì‚´ì§ ë†’ê²Œ
                    parent: 'root'
                };
                nodes.push(headNode);

                // Children
                let currentY = startY_pos + VERTICAL_GAP + 10;
                col.children.forEach(child => {
                    nodes.push({
                        ...child,
                        x: colX,
                        y: currentY,
                        w: NODE_WIDTH,
                        h: NODE_HEIGHT,
                        parent: headNode
                    });
                    currentY += VERTICAL_GAP;
                });
            });

            centerView();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }

        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function drawConnection(p1, p2) {
            if (!p1 || !p2) return;

            ctx.beginPath();
            ctx.moveTo(p1.x + p1.w / 2, p1.y + p1.h);
            
            // ë² ì§€ì–´ ê³¡ì„  ì œì–´ì  (ìˆ˜ì§ìœ¼ë¡œ ë‚´ë ¤ì™”ë‹¤ ë“¤ì–´ê°)
            const cp1x = p1.x + p1.w / 2;
            const cp1y = p1.y + p1.h + 30;
            const cp2x = p2.x + p2.w / 2;
            const cp2y = p2.y - 30;

            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x + p2.w / 2, p2.y);
            
            ctx.strokeStyle = COLORS.line;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawNode(node) {
            const style = COLORS[node.type] || COLORS.gray;
            const x = node.x;
            const y = node.y;
            
            // Shadow
            ctx.shadowColor = "rgba(0, 0, 0, 0.1)";
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 4;

            // Box Background
            ctx.fillStyle = style.fill;
            drawRoundedRect(ctx, x, y, node.w, node.h, RADIUS);
            ctx.fill();

            // Highlight if hovered
            if (hoveredNode === node) {
                ctx.strokeStyle = '#2980b9';
                ctx.lineWidth = 3;
            } else {
                ctx.strokeStyle = style.stroke;
                ctx.lineWidth = 1.5;
            }
            ctx.stroke();

            // Reset Shadow for text
            ctx.shadowColor = "transparent";
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Text
            ctx.fillStyle = style.text;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = node.type === 'root' ? 'bold 16px "Noto Sans KR"' : '500 14px "Noto Sans KR"';
            
            const lines = node.text.split('\n');
            const lineHeight = 18;
            const startY = y + (node.h / 2) - ((lines.length - 1) * lineHeight / 2);

            lines.forEach((line, i) => {
                ctx.fillText(line, x + node.w / 2, startY + (i * lineHeight));
            });
        }

        function drawGrid() {
            const gridSize = 40 * scale;
            const w = canvas.width;
            const h = canvas.height;
            const ox = offsetX % gridSize;
            const oy = offsetY % gridSize;

            ctx.beginPath();
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;

            for (let x = ox; x < w; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
            }
            for (let y = oy; y < h; y += gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
            }
            ctx.stroke();
        }

        function draw(isExporting = false) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ë‚´ë³´ë‚´ê¸° ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ ë°°ê²½ ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
            if (!isExporting) {
                drawGrid();
            }

            ctx.save();
            
            if (isExporting) {
                // ë‚´ë³´ë‚´ê¸° ì‹œ: ìº”ë²„ìŠ¤ í¬ê¸°ì— ë§ì¶° ë‚´ìš©ì´ ì¤‘ì•™ì— ì˜¤ë„ë¡ ì¡°ì • (ì´ë¯¸ ì™¸ë¶€ì—ì„œ ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ë§ì¶¤)
                // í•˜ì§€ë§Œ drawNode ë“±ì€ ì ˆëŒ€ ì¢Œí‘œë¥¼ ì“°ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” ì „ì²´ ë…¸ë“œë“¤ì„ ê°ì‹¸ëŠ” ì˜¤í”„ì…‹ë§Œí¼ ì´ë™í•´ì¤˜ì•¼ í•¨.
                // ì´ ë¡œì§ì€ downloadImage í•¨ìˆ˜ì—ì„œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ë” ê¹”ë”í•˜ë¯€ë¡œ, 
                // ì—¬ê¸°ì„œëŠ” transformì„ ì ìš©í•˜ì§€ ì•Šê±°ë‚˜, ì™¸ë¶€ì—ì„œ ì„¤ì •í•œ transformì„ ë”°ë¦…ë‹ˆë‹¤.
                // export ë¡œì§ì€ ë³„ë„ë¡œ ë¶„ë¦¬í•©ë‹ˆë‹¤.
            } else {
                ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
                ctx.scale(scale, scale);
            }

            // 1. Draw Connections first
            const rootNode = nodes.find(n => n.id === 'root');
            nodes.filter(n => n.parent === 'root').forEach(child => {
                drawConnection(rootNode, child);
            });
            
            // 2. Draw Nodes
            nodes.forEach(node => {
                drawNode(node);
            });

            ctx.restore();
        }

        // ì´ë¯¸ì§€ ì €ì¥ ê¸°ëŠ¥
        function downloadImage() {
            // 1. ì „ì²´ ë…¸ë“œë¥¼ í¬í•¨í•˜ëŠ” ì˜ì—­ ê³„ì‚°
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + node.w);
                maxY = Math.max(maxY, node.y + node.h);
            });

            // ì—¬ë°± ì¶”ê°€
            const padding = 50;
            const width = maxX - minX + (padding * 2);
            const height = maxY - minY + (padding * 2);

            // 2. í˜„ì¬ ìƒíƒœ ì €ì¥
            const originalWidth = canvas.width;
            const originalHeight = canvas.height;
            const originalScale = scale;
            const originalOffsetX = offsetX;
            const originalOffsetY = offsetY;

            // 3. ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì „ì²´ ë‚´ìš©ì— ë§ê²Œ ì„ì‹œ ë³€ê²½
            canvas.width = width;
            canvas.height = height;

            // 4. ë°°ê²½ ì—†ì´ ê·¸ë¦¬ê¸° (ìˆ˜ë™ draw)
            ctx.clearRect(0, 0, width, height);
            ctx.save();
            // ëª¨ë“  ë…¸ë“œê°€ (0,0) ê¸°ì¤€ì´ ì•„ë‹ˆë¼ ì¤‘ì•™ ê¸°ì¤€ ì¢Œí‘œê³„ì´ë¯€ë¡œ, 
            // ê°€ì¥ ì™¼ìª½/ìœ„ìª½ ë…¸ë“œê°€ (padding, padding)ì— ì˜¤ë„ë¡ ì´ë™
            ctx.translate(-minX + padding, -minY + padding);
            
            // ì—°ê²°ì„  ê·¸ë¦¬ê¸°
            const rootNode = nodes.find(n => n.id === 'root');
            nodes.filter(n => n.parent === 'root').forEach(child => {
                drawConnection(rootNode, child);
            });
            // ë…¸ë“œ ê·¸ë¦¬ê¸°
            nodes.forEach(node => {
                drawNode(node);
            });
            ctx.restore();

            // 5. ë‹¤ìš´ë¡œë“œ íŠ¸ë¦¬ê±°
            const link = document.createElement('a');
            link.download = 'ë¶„ë¦¬ë°°ì¶œ_ì„œë¹„ìŠ¤_êµ¬ì¡°ë„.png';
            link.href = canvas.toDataURL('image/png');
            link.click();

            // 6. ìƒíƒœ ë³µêµ¬
            canvas.width = originalWidth;
            canvas.height = originalHeight;
            // draw() í•¨ìˆ˜ê°€ scale, offsetX ë“±ì„ ì‚¬ìš©í•˜ë¯€ë¡œ ë³€ìˆ˜ ë³µêµ¬ ë¶ˆí•„ìš” (ë³€ìˆ˜ ìì²´ëŠ” ì•ˆ ë°”ë€œ)
            draw();
        }

        // View Control Functions
        function centerView() {
            offsetX = 0;
            offsetY = 150; // ì¡°ê¸ˆ ì•„ë˜ë¡œ ë‚´ë ¤ì„œ ì‹œì‘
            scale = 0.8;
            draw();
        }

        function resetView() {
            centerView();
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left - canvas.width / 2 - offsetX) / scale,
                y: (e.clientY - rect.top - canvas.height / 2 - offsetY) / scale
            };
        }

        // Event Listeners
        window.addEventListener('resize', resizeCanvas);

        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            startX = e.clientX - offsetX;
            startY = e.clientY - offsetY;
            container.style.cursor = 'grabbing';
        });

        window.addEventListener('mousemove', e => {
            if (isDragging) {
                offsetX = e.clientX - startX;
                offsetY = e.clientY - startY;
                draw();
            } else {
                // Hover Check
                const pos = getMousePos(e);
                const prevHover = hoveredNode;
                hoveredNode = null;
                
                for (const node of nodes) {
                    if (pos.x >= node.x && pos.x <= node.x + node.w &&
                        pos.y >= node.y && pos.y <= node.y + node.h) {
                        hoveredNode = node;
                        break;
                    }
                }

                if (prevHover !== hoveredNode) {
                    canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
                    draw();
                }
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            container.style.cursor = 'grab';
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSensitivity = 0.001;
            const delta = -e.deltaY * zoomSensitivity;
            const newScale = Math.min(Math.max(0.2, scale + delta), 3);
            
            // Zoom towards mouse pointer logic could be added here, 
            // but simple center zoom is often enough for this use case
            scale = newScale;
            draw();
        }, { passive: false });

        // Initialize
        initLayout();
        resizeCanvas();

    </script>
</body>
</html>